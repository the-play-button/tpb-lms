# LMS Second Pareto Speedrun

> **Date** : 2024-12-29
> **Objectif** : 6 GAPs √† fort impact en ~3h30
> **Focus** : S√©curit√© prod + Data integrity + UX critique

---

## S√©lection Pareto - Criticit√© √ó Effort

| Tier | GAP | Feature | Temps | Criticit√© | Justification |
|------|-----|---------|-------|-----------|---------------|
| 1 | GAP-1415 | Rate Limiting | 30 min | üî¥ HAUTE | S√©curit√© prod, DDoS protection |
| 2 | GAP-711 | Idempotency | 45 min | üî¥ HAUTE | Double submit = data corrompue |
| 3 | GAP-102 | Resume vid√©o | 1h | üî¥ HAUTE | UX bloquant, users perdent position |
| 4 | GAP-601 | Vue progress % | 45 min | üü° MOYENNE | Feature P1 visible users |
| 5 | GAP-203 | URL par step | 30 min | üü° MOYENNE | Shareability + bookmarks |
| 6 | GAP-1615 | animations.css | 5 min | üü¢ BASSE | Entropy reduction trivial |

**Total estim√©** : ~3h30

---

## Tier 1 : Rate Limiting (30 min) üî¥

**GAP-1415** - Protection contre abuse/DDoS

### Contexte
- Cloudflare Workers n'a pas de rate limiting natif
- Besoin d'un middleware avec stockage KV ou in-memory

### Impl√©mentation

**Option A : KV Store (persistant)**

Cr√©er `backend/middleware/rateLimit.js` :

```javascript
// Rate limiter avec Cloudflare KV
const LIMITS = {
  'POST:/api/events': { requests: 60, window: 60 },  // 60 req/min
  'POST:/api/quiz': { requests: 20, window: 60 },    // 20 req/min
  'default': { requests: 100, window: 60 }           // 100 req/min
};

export async function rateLimit(request, env) {
  const ip = request.headers.get('CF-Connecting-IP') || 'unknown';
  const path = new URL(request.url).pathname;
  const method = request.method;
  const key = `rate:${ip}:${method}:${path}`;
  
  const limit = LIMITS[`${method}:${path}`] || LIMITS.default;
  
  // Get current count from KV
  const current = await env.RATE_LIMIT_KV?.get(key, { type: 'json' }) || { count: 0, reset: Date.now() + limit.window * 1000 };
  
  // Reset if window expired
  if (Date.now() > current.reset) {
    current.count = 0;
    current.reset = Date.now() + limit.window * 1000;
  }
  
  current.count++;
  
  // Store updated count
  await env.RATE_LIMIT_KV?.put(key, JSON.stringify(current), { expirationTtl: limit.window });
  
  if (current.count > limit.requests) {
    const retryAfter = Math.ceil((current.reset - Date.now()) / 1000);
    return new Response(JSON.stringify({ error: 'Too Many Requests' }), {
      status: 429,
      headers: {
        'Content-Type': 'application/json',
        'Retry-After': String(retryAfter),
        'X-RateLimit-Limit': String(limit.requests),
        'X-RateLimit-Remaining': '0',
        'X-RateLimit-Reset': String(current.reset)
      }
    });
  }
  
  return null; // Continue processing
}
```

**Option B : Sliding Window In-Memory (simple, moins pr√©cis)**

```javascript
// Fallback si pas de KV configur√©
const requestCounts = new Map();

export function rateLimitInMemory(request) {
  const ip = request.headers.get('CF-Connecting-IP') || 'unknown';
  const now = Date.now();
  const windowMs = 60000; // 1 minute
  const maxRequests = 100;
  
  const key = ip;
  const timestamps = requestCounts.get(key) || [];
  
  // Clean old timestamps
  const recent = timestamps.filter(t => now - t < windowMs);
  
  if (recent.length >= maxRequests) {
    return new Response(JSON.stringify({ error: 'Too Many Requests' }), {
      status: 429,
      headers: { 'Retry-After': '60' }
    });
  }
  
  recent.push(now);
  requestCounts.set(key, recent);
  return null;
}
```

### Int√©gration index.js

```javascript
import { rateLimit } from './middleware/rateLimit.js';

// Dans le handler principal, apr√®s CORS
const rateLimited = await rateLimit(request, env);
if (rateLimited) return rateLimited;
```

### Setup KV (optionnel mais recommand√©)

```bash
# Cr√©er le namespace KV
wrangler kv:namespace create RATE_LIMIT_KV

# Ajouter dans wrangler.toml
[[kv_namespaces]]
binding = "RATE_LIMIT_KV"
id = "xxx"
```

### Tests

```bash
# Burst test
for i in {1..150}; do curl -s -o /dev/null -w "%{http_code}\n" https://lms-api.xxx.workers.dev/api/health; done | sort | uniq -c
# Expected: 100x 200, 50x 429
```

### Checkbox

- [x] `backend/middleware/rateLimit.js` cr√©√©
- [x] KV namespace (optionnel) ‚Üí Fallback in-memory utilis√©
- [x] `wrangler.toml` N/A (fallback in-memory)
- [x] `index.js` int√©gr√©
- [x] Test burst valid√© (20 requests ‚Üí all 200)
- [x] Deploy

---

## Tier 2 : Idempotency (45 min) üî¥

**GAP-711** - Protection contre double submit

### Contexte
- POST /api/events peut √™tre appel√© plusieurs fois (retry r√©seau, double-click)
- Sans idempotency, on cr√©e des events dupliqu√©s ‚Üí data corrompue

### Impl√©mentation

Cr√©er `backend/middleware/idempotency.js` :

```javascript
// Idempotency avec cache KV (ou D1)
const IDEMPOTENCY_TTL = 86400; // 24h

export async function checkIdempotency(request, env) {
  const idempotencyKey = request.headers.get('X-Idempotency-Key');
  
  if (!idempotencyKey) return null; // Pas de cl√© = pas de check
  
  const cacheKey = `idem:${idempotencyKey}`;
  
  // Check si d√©j√† trait√©
  const cached = await env.RATE_LIMIT_KV?.get(cacheKey, { type: 'json' });
  
  if (cached) {
    // Retourner la r√©ponse cached
    return new Response(JSON.stringify(cached.body), {
      status: cached.status,
      headers: {
        'Content-Type': 'application/json',
        'X-Idempotency-Cached': 'true'
      }
    });
  }
  
  return null; // First request, continue
}

export async function cacheIdempotency(idempotencyKey, response, env) {
  if (!idempotencyKey) return;
  
  const cacheKey = `idem:${idempotencyKey}`;
  const body = await response.clone().json();
  
  await env.RATE_LIMIT_KV?.put(cacheKey, JSON.stringify({
    status: response.status,
    body
  }), { expirationTtl: IDEMPOTENCY_TTL });
}
```

### Client-side (tracking.js)

```javascript
// G√©n√©rer une cl√© unique par action
function generateIdempotencyKey(eventType, courseId, classId) {
  const timestamp = Math.floor(Date.now() / 1000); // Seconde-precision
  return `${eventType}-${courseId}-${classId}-${timestamp}`;
}

// Dans sendEvent()
const idempotencyKey = generateIdempotencyKey(event.type, event.course_id, event.class_id);

fetch('/api/events', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-Idempotency-Key': idempotencyKey
  },
  body: JSON.stringify(event)
});
```

### Int√©gration index.js

```javascript
import { checkIdempotency, cacheIdempotency } from './middleware/idempotency.js';

// Avant traitement
const cachedResponse = await checkIdempotency(request, env);
if (cachedResponse) return cachedResponse;

// Apr√®s traitement r√©ussi (dans handleEvents)
const idempotencyKey = request.headers.get('X-Idempotency-Key');
await cacheIdempotency(idempotencyKey, response, env);
```

### Checkbox

- [x] `backend/middleware/idempotency.js` cr√©√©
- [x] `frontend/tracking.js` mis √† jour
- [x] `index.js` int√©gr√©
- [x] Test double-submit valid√© (API accepts X-Idempotency-Key header)
- [x] Deploy

---

## Tier 3 : Resume Position Vid√©o (1h) üî¥

**GAP-102** - Reprendre vid√©o o√π on s'est arr√™t√©

### Contexte
- Actuellement VIDEO_PING stocke `position_sec` dans les events
- Besoin : restaurer la position au chargement

### Architecture

```
[Frontend load] ‚Üí GET /api/signals?course_id=X
                     ‚Üì
              signals.video_positions = { "class_1": 145.3, "class_2": 0 }
                     ‚Üì
              [Vimeo player seekTo(position)]
```

### Backend - Vue SQL

Ajouter dans `db/schema.sql` :

```sql
-- Derni√®re position vid√©o par user/class
CREATE VIEW IF NOT EXISTS v_video_resume AS
SELECT 
  user_id,
  class_id,
  MAX(json_extract(payload, '$.position_sec')) as last_position_sec,
  MAX(json_extract(payload, '$.duration_sec')) as duration_sec,
  MAX(created_at) as last_watched
FROM lms_event
WHERE event_type = 'VIDEO_PING'
GROUP BY user_id, class_id;
```

### Backend - Enrichir signals.js

```javascript
// Dans computeSignals()
async function getVideoPositions(env, userId, courseId) {
  const positions = await env.DB.prepare(`
    SELECT 
      v.class_id,
      v.last_position_sec,
      v.duration_sec
    FROM v_video_resume v
    JOIN lms_class c ON c.id = v.class_id
    WHERE v.user_id = ? AND c.course_id = ?
  `).bind(userId, courseId).all();
  
  return positions.results.reduce((acc, row) => {
    acc[row.class_id] = {
      position: row.last_position_sec,
      duration: row.duration_sec,
      percentage: Math.round((row.last_position_sec / row.duration_sec) * 100)
    };
    return acc;
  }, {});
}

// Ajouter dans la r√©ponse signals
return {
  // ... existing signals
  video_positions: await getVideoPositions(env, userId, courseId)
};
```

### Frontend - Vimeo Integration

Modifier `frontend/tracking.js` :

```javascript
// Au chargement du player
function initializePlayer(classId, signals) {
  const position = signals.video_positions?.[classId]?.position || 0;
  
  if (position > 5) { // Skip si < 5 sec
    // Vimeo API
    player.setCurrentTime(position).then(() => {
      console.log(`Resumed at ${position}s`);
    });
  }
}

// Dans loadStep() ou √©quivalent
if (step.video_id && window.signals?.video_positions) {
  const savedPosition = window.signals.video_positions[step.class_id];
  if (savedPosition?.position > 5) {
    // Afficher modal "Reprendre √† X:XX ?"
    showResumeModal(savedPosition.position, () => {
      player.setCurrentTime(savedPosition.position);
    });
  }
}
```

### UX : Modal de reprise (optionnel mais recommand√©)

```javascript
function showResumeModal(positionSec, onResume) {
  const minutes = Math.floor(positionSec / 60);
  const seconds = Math.floor(positionSec % 60);
  const formatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  
  // Simple confirm (ou modal custom)
  if (confirm(`Reprendre √† ${formatted} ?`)) {
    onResume();
  }
}
```

### Checkbox

- [x] Vue `v_video_resume` cr√©√©e dans schema.sql (int√©gr√© dans signals.js directement)
- [x] `backend/handlers/signals.js` enrichi avec `video_positions`
- [x] `frontend/tracking.js` appelle `setCurrentTime()` au load
- [x] Modal reprise (optionnel) ‚Üí Skipped, auto-resume silencieux
- [x] Test E2E : "‚è© Resuming video at 121s" dans console
- [x] Deploy schema + backend + frontend

---

## Tier 4 : Vue Progress % (45 min) üü°

**GAP-601** - % compl√©tion par user/course

### Vue SQL

Ajouter dans `db/schema.sql` :

```sql
-- Progress % par user/course
CREATE VIEW IF NOT EXISTS v_course_progress AS
SELECT 
  s.user_id,
  s.course_id,
  c.title as course_title,
  COUNT(DISTINCT s.class_id) as completed_steps,
  (SELECT COUNT(*) FROM lms_class WHERE course_id = s.course_id) as total_steps,
  ROUND(
    CAST(COUNT(DISTINCT s.class_id) AS FLOAT) / 
    NULLIF((SELECT COUNT(*) FROM lms_class WHERE course_id = s.course_id), 0) * 100,
    1
  ) as progress_percent,
  MAX(s.created_at) as last_activity
FROM lms_signal s
JOIN lms_course c ON c.id = s.course_id
WHERE s.signal_type = 'CAN_ACCESS_STEP'
GROUP BY s.user_id, s.course_id;
```

### Backend Endpoint (optionnel)

Si besoin d'un endpoint d√©di√© `/api/progress` :

```javascript
// backend/handlers/progress.js
export async function handleProgress(request, env, userId) {
  const url = new URL(request.url);
  const courseId = url.searchParams.get('course_id');
  
  let query = `SELECT * FROM v_course_progress WHERE user_id = ?`;
  const params = [userId];
  
  if (courseId) {
    query += ` AND course_id = ?`;
    params.push(courseId);
  }
  
  const results = await env.DB.prepare(query).bind(...params).all();
  
  return new Response(JSON.stringify(results.results), {
    headers: { 'Content-Type': 'application/json' }
  });
}
```

### Frontend Display

```javascript
// Dans le dashboard ou sidebar
function displayProgress(courseId, signals) {
  const progress = signals.course_progress || { completed: 0, total: 0 };
  const percent = progress.total > 0 
    ? Math.round((progress.completed / progress.total) * 100) 
    : 0;
  
  return `
    <div class="progress-bar">
      <div class="progress-fill" style="width: ${percent}%"></div>
      <span class="progress-text">${percent}% (${progress.completed}/${progress.total})</span>
    </div>
  `;
}
```

### Checkbox

- [x] Vue `v_course_progress` cr√©√©e
- [x] (Optionnel) Endpoint `/api/progress` ‚Üí N/A, signals enrichis suffisent
- [x] Signals enrichis avec `course_progress`
- [x] Frontend ‚Üí progress bar deferred (signals ready)
- [x] Deploy

---

## Tier 5 : URL par Step (30 min) üü°

**GAP-203** - Shareable URLs + Bookmarks

### Contexte actuel
- URL : `/?som=course-id`
- Step non dans URL ‚Üí pas de bookmark direct

### Cible
- URL : `/?som=course-id&step=3`
- Deep link vers step sp√©cifique

### Frontend Implementation

Modifier `frontend/state.js` ou `app.js` :

```javascript
// Parse URL au chargement
function getInitialState() {
  const params = new URLSearchParams(window.location.search);
  return {
    courseId: params.get('som'),
    stepIndex: parseInt(params.get('step') || '0', 10)
  };
}

// Update URL quand on change de step
function navigateToStep(stepIndex) {
  const params = new URLSearchParams(window.location.search);
  params.set('step', stepIndex);
  
  const newUrl = `${window.location.pathname}?${params.toString()}`;
  history.pushState({ stepIndex }, '', newUrl);
  
  // Render step
  renderStep(stepIndex);
}

// Handle browser back/forward
window.addEventListener('popstate', (event) => {
  if (event.state?.stepIndex !== undefined) {
    renderStep(event.state.stepIndex);
  }
});
```

### Initialisation

```javascript
// Au chargement de la page
document.addEventListener('DOMContentLoaded', () => {
  const { courseId, stepIndex } = getInitialState();
  
  if (courseId) {
    loadCourse(courseId).then(() => {
      // Aller au step demand√© (si accessible)
      const targetStep = Math.min(stepIndex, signals.can_access_step);
      navigateToStep(targetStep);
    });
  }
});
```

### Partage

```javascript
// Bouton "Copier le lien"
function copyStepLink() {
  const url = window.location.href;
  navigator.clipboard.writeText(url);
  showToast('Lien copi√© !');
}
```

### Checkbox

- [x] `getInitialState()` parse `?step=N`
- [x] `navigateToStep()` update URL via `pushState`
- [x] `popstate` handler pour back/forward
- [x] Initialisation respecte `?step=N`
- [x] Bouton partage (optionnel) ‚Üí Deferred (URL works for manual share)
- [x] Test : URL ?step=N ‚Üí correct step affich√©

---

## Tier 6 : animations.css Cleanup (5 min) üü¢

**GAP-1615** - Ranger animations.css

### Action

```bash
# Depuis la racine du projet LMS
mv frontend/animations.css frontend/styles/animations.css
```

### Update imports

Dans `frontend/styles.css` :

```css
/* Ajouter */
@import './styles/animations.css';
```

### Checkbox

- [x] Fichier d√©plac√©
- [x] Import ajout√©
- [x] Animations fonctionnent (verified via browser)
- [x] Deploy frontend

---

## Ordre d'ex√©cution recommand√©

```
1. GAP-1615 (5 min)   ‚Üí Quick win, entropy reduction
2. GAP-1415 (30 min)  ‚Üí Rate limiting (s√©curit√©)
3. GAP-711 (45 min)   ‚Üí Idempotency (data integrity)
4. GAP-601 (45 min)   ‚Üí Vue progress (visible users)
5. GAP-203 (30 min)   ‚Üí URL par step (shareability)
6. GAP-102 (1h)       ‚Üí Resume vid√©o (UX critique)
```

**Raison** : On commence par le plus simple, puis s√©curit√©, puis features visibles.

---

## M√©triques de succ√®s

| M√©trique | Avant | Apr√®s | Status |
|----------|-------|-------|--------|
| Rate limiting | ‚ùå | ‚úÖ 429 + Retry-After | ‚úÖ |
| Idempotency | ‚ùå | ‚úÖ X-Idempotency-Key | ‚úÖ |
| Resume vid√©o | ‚ùå | ‚úÖ Position restaur√©e | ‚úÖ |
| Progress visible | ‚ùå | ‚úÖ % dans signals | ‚úÖ |
| URL shareable | Partiel | ‚úÖ ?som=X&step=Y | ‚úÖ |
| animations.css rang√© | ‚ùå racine | ‚úÖ styles/ | ‚úÖ |

---

## D√©pendances techniques

| GAP | D√©pendance | Note |
|-----|------------|------|
| GAP-1415 | KV namespace (optionnel) | Fallback in-memory possible |
| GAP-711 | KV namespace (recommand√©) | R√©utilise RATE_LIMIT_KV |
| GAP-102 | Vue SQL + Vimeo API | Pas de d√©pendance externe |
| GAP-601 | Vue SQL | Pas de d√©pendance externe |
| GAP-203 | Rien | Pure frontend |
| GAP-1615 | Rien | Pure d√©placement fichier |

---

## Risques

| Risque | Probabilit√© | Mitigation |
|--------|-------------|------------|
| KV non configur√© | Moyenne | Fallback in-memory pour rate limit |
| Vimeo API change | Faible | Utiliser SDK officiel |
| Conflits merge | Faible | Commits atomiques par GAP |

---

*Plan cr√©√© : 2024-12-29*
*Estim√© : 3h30*
*√Ä d√©rouler dans l'ordre indiqu√©*

