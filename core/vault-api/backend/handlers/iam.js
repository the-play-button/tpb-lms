/**
 * IAM Service Token Management
 * 
 * Handles self-service creation of Cloudflare Access Service Tokens
 * for development environments.
 * 
 * Intent + Guard pattern (IAMPAM):
 * - Intent: credentials:create, credentials:read, credentials:revoke
 * - Subject: ctx.actor.id (email from JWT)
 * - Resource: Service Token
 * - Guard: Require email auth (not service token)
 * 
 * IMPORTANT: Token creation now uses cfAccess controller to:
 * 1. Create the token
 * 2. Add policy to vault-api Access app (atomic operation)
 */

import { error, success } from '../utils/response.js';
import { getCfAccessController } from '../services/cfAccess.js';
import { logAudit } from './audit.js';

const VAULT_APP_NAME = 'tpb-vault-infra';
const DEFAULT_ORG_ID = 'org_tpb';

// Default scopes for personal service tokens (developer tokens)
// vault:secret:* - full access to secrets (read/write/delete)
const DEFAULT_PERSONAL_TOKEN_SCOPES = 'vault:secret:*';

/**
 * List service tokens created by the current user
 * GET /iam/service-tokens
 */
export async function listServiceTokens(request, env, ctx) {
  try {
    // Guard: Only email auth allowed (not service tokens)
    if (ctx.actor.type !== 'user') {
      return error('Email authentication required', 403, 'FORBIDDEN');
    }

    const { results } = await env.DB.prepare(`
      SELECT 
        id,
        name,
        created_at,
        revoked_at,
        cf_token_id
      FROM iam_service_token 
      WHERE subject_email = ? 
      ORDER BY created_at DESC
    `).bind(ctx.actor.id).all();

    return success({
      tokens: results.map(token => ({
        id: token.id,
        name: token.name,
        created_at: token.created_at,
        revoked_at: token.revoked_at,
        active: !token.revoked_at
      }))
    });

  } catch (err) {
    console.error('List service tokens error:', err);
    return error(`Failed to list tokens: ${err.message}`, 500);
  }
}

/**
 * Create a new service token
 * POST /iam/service-tokens
 */
export async function createServiceToken(request, env, ctx) {
  try {
    // Guard: Only email auth allowed (not service tokens)
    if (ctx.actor.type !== 'user') {
      return error('Email authentication required', 403, 'FORBIDDEN');
    }

    const body = await request.json().catch(() => ({}));
    const tokenName = body.name || `dev-container-${ctx.actor.id.replace('@', '-at-').replace(/\./g, '-')}`;

    // Check if user already has an active token with this name
    const { results: existing } = await env.DB.prepare(`
      SELECT id FROM iam_service_token 
      WHERE subject_email = ? AND name = ? AND revoked_at IS NULL
    `).bind(ctx.actor.id, tokenName).all();

    if (existing.length > 0) {
      return error(`Active token with name '${tokenName}' already exists`, 409, 'CONFLICT');
    }

    // Create service token + policy via cfAccess controller (atomic)
    let serviceToken;
    try {
      const cf = getCfAccessController(env);
      serviceToken = await cf.createServiceTokenWithAccess(tokenName, VAULT_APP_NAME);
    } catch (err) {
      console.error('Cloudflare API error:', err);
      return error(`Failed to create service token: ${err.message}`, 502, 'CLOUDFLARE_ERROR');
    }

    // Store in D1 with cf_client_id and default scopes
    const tokenId = crypto.randomUUID();
    await env.DB.prepare(`
      INSERT INTO iam_service_token (
        id, organization_id, cf_token_id, cf_client_id, subject_email, name, scopes, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      tokenId,
      DEFAULT_ORG_ID,
      serviceToken.tokenId,
      serviceToken.clientId,  // Store for auth lookup
      ctx.actor.id,
      tokenName,
      DEFAULT_PERSONAL_TOKEN_SCOPES,  // vault:secret:* by default
      new Date().toISOString()
    ).run();

    // Audit log via logAudit (uses correct schema columns)
    await logAudit(env, {
      action: 'credentials:create',
      actor_id: ctx.actor.id,
      actor_type: 'user',
      context: {
        resource_type: 'service_token',
        resource_id: tokenId,
        token_name: tokenName,
        ip_address: request.headers.get('CF-Connecting-IP') || 'unknown',
        user_agent: request.headers.get('User-Agent') || 'unknown'
      }
    });

    return success({
      token: {
        id: tokenId,
        name: tokenName,
        client_id: serviceToken.clientId,
        client_secret: serviceToken.clientSecret,
        expires_at: serviceToken.expiresAt,
        created_at: new Date().toISOString()
      },
      env_file: `# TPB Dev Container Credentials
# Generated by vault-api on ${new Date().toISOString()}
# vault-api est la SSOT - ces credentials te donnent acces au vault
VAULT_CLIENT_ID=${serviceToken.clientId}
VAULT_CLIENT_SECRET=${serviceToken.clientSecret}`,
      note: 'Token + vault-api access policy created. Copy env_file content to .devcontainer/.env'
    });

  } catch (err) {
    console.error('Create service token error:', err);
    return error(`Failed to create token: ${err.message}`, 500);
  }
}

/**
 * Revoke a service token
 * DELETE /iam/service-tokens/:tokenId
 */
export async function revokeServiceToken(request, env, ctx) {
  try {
    // Guard: Only email auth allowed (not service tokens)
    if (ctx.actor.type !== 'user') {
      return error('Email authentication required', 403, 'FORBIDDEN');
    }

    const tokenId = ctx.params.tokenId;

    // Get token info (ensure user owns it)
    const { results } = await env.DB.prepare(`
      SELECT cf_token_id, name FROM iam_service_token 
      WHERE id = ? AND subject_email = ? AND revoked_at IS NULL
    `).bind(tokenId, ctx.actor.id).all();

    if (results.length === 0) {
      return error('Token not found or already revoked', 404, 'NOT_FOUND');
    }

    const token = results[0];

    // Revoke token + remove policy via cfAccess controller
    try {
      const cf = getCfAccessController(env);
      await cf.revokeServiceTokenWithAccess(token.cf_token_id, VAULT_APP_NAME);
    } catch (err) {
      console.error('Cloudflare revoke error:', err);
      return error(`Failed to revoke service token: ${err.message}`, 502, 'CLOUDFLARE_ERROR');
    }

    // Mark as revoked in D1
    await env.DB.prepare(`
      UPDATE iam_service_token 
      SET revoked_at = ? 
      WHERE id = ?
    `).bind(new Date().toISOString(), tokenId).run();

    // Audit log via logAudit (uses correct schema columns)
    await logAudit(env, {
      action: 'credentials:revoke',
      actor_id: ctx.actor.id,
      actor_type: 'user',
      context: {
        resource_type: 'service_token',
        resource_id: tokenId,
        token_name: token.name,
        ip_address: request.headers.get('CF-Connecting-IP') || 'unknown',
        user_agent: request.headers.get('User-Agent') || 'unknown'
      }
    });

    return success({
      message: `Service token '${token.name}' revoked successfully`,
      revoked_at: new Date().toISOString()
    });

  } catch (err) {
    console.error('Revoke service token error:', err);
    return error(`Failed to revoke token: ${err.message}`, 500);
  }
}

/**
 * Cleanup orphan service tokens (exist on CF but not in D1)
 * DELETE /iam/service-tokens/orphans
 */
export async function cleanupOrphanTokens(request, env, ctx) {
  try {
    // Guard: Only admins (email auth with admin role)
    if (ctx.actor.type !== 'user') {
      return error('Email authentication required', 403, 'FORBIDDEN');
    }
    if (ctx.actor.role !== 'superadmin' && ctx.actor.role !== 'admin') {
      return error('Admin privileges required', 403, 'FORBIDDEN');
    }

    const cf = getCfAccessController(env);
    
    // Get all tokens from CF
    const cfTokens = await cf.listServiceTokens();
    const cfTokenIds = new Set(cfTokens.map(t => t.id));
    
    // Get all active tokens from D1
    const { results: d1Tokens } = await env.DB.prepare(`
      SELECT cf_token_id FROM iam_service_token WHERE revoked_at IS NULL
    `).all();
    const d1TokenIds = new Set(d1Tokens.map(t => t.cf_token_id));
    
    // Find orphans (on CF but not in D1)
    const orphanIds = [...cfTokenIds].filter(id => !d1TokenIds.has(id));
    
    if (orphanIds.length === 0) {
      return success({
        message: 'No orphan tokens found',
        deleted: 0
      });
    }
    
    // Delete orphans from CF (including their policies)
    const deleted = [];
    const failed = [];
    
    for (const tokenId of orphanIds) {
      try {
        // Use revokeServiceTokenWithAccess to also remove policies
        await cf.revokeServiceTokenWithAccess(tokenId, VAULT_APP_NAME);
        deleted.push(tokenId);
      } catch (err) {
        console.error(`Failed to delete orphan token ${tokenId}:`, err);
        failed.push({ id: tokenId, error: err.message });
      }
    }
    
    // Audit log
    await logAudit(env, {
      action: 'credentials:cleanup_orphans',
      actor_id: ctx.actor.id,
      actor_type: 'user',
      context: {
        deleted_count: deleted.length,
        failed_count: failed.length,
        ip_address: request.headers.get('CF-Connecting-IP') || 'unknown'
      }
    });

    return success({
      message: `Cleaned up ${deleted.length} orphan tokens`,
      deleted: deleted.length,
      deleted_ids: deleted,
      failed: failed.length > 0 ? failed : undefined
    });

  } catch (err) {
    console.error('Cleanup orphan tokens error:', err);
    return error(`Failed to cleanup orphans: ${err.message}`, 500);
  }
}
